# Ideas

- [ ] day 0
- [ ] how this blog is built
- [ ] airpods on linux with pipewire
- [ ] colored emojis in linux terminal
- [ ] should site has dark mode setting? (dark reader vs css theming vs prefers-color-theme)
- [ ] sites should be so simple that you can read them without a browser
- [ ] world of ergonomic mechanical keyboards
- [ ] advent of code as a motivation to learn something new
- [ ] cookie consent is a joke
- [ ] terminal interfaces with haskell and brick
- [ ] liquidity vs corporate benefits
- [ ] new approach to building user interfaces (using Elm)
- [ ] NFT: fabulous technology vs reality
- [ ] 4-day work week (timezone magic)
- [ ] martian time standards
- [ ] monad is an interface that can bind and return
- [ ] the only bash shortcut you will ever need (^R)
- [ ] read oriented design (read, not write; listen, not talk) (MS Teams mic on by default and vim)
- [ ] tools should be a responsibility of the library/language developers
- [ ] 2022-02-22 magic dates of our lifetime
- [ ] social networks without community moderation are dangerous to society
- [ ] how LLMs are suppose to invent new information if they live in a sealed box
- [ ] programming language semantics/syntax we go by just because first compilers where not smart enough
  - semicolons
  - declare before use
  - excessive punctuaction
- [ ] why you should make your next game in HTML
  - game distribution is easy
  - immediately cross-platform with Electron/Tauri
  - you get the richest UI support
  - always online
  - JS performance is often not the bottleneck, and gets faster every day, and WASM is available for critical pieces
  - WebGL has on par performance with WebGL
- [ ] so you want to make a programming language
  - what it takes
  - realistic scope for one dev
  - ways to go around it
  - simple problems that look complicated and complicated problems that look similar
  - near impossible to get semantics right on the first try
- [ ] all of these are related in some way:
  - coroutines
  - generators (yield)
  - async/await
  - futures/promises
  - fibers
  - (Delimited, scoped) continuations
  - monads
  - algebraic effects
  what approach a language of the future should look at?
- [ ] kinds of tasks in programming
  - e.g. parsing, mapping, calculating in a loop, delegation, etc.
- [ ] inventions & discoveries of the human race
  - log time scale
- [ ] source code is your friend
  - code is the source of truth
  - don't be afraid to look at others code
  - technologies below you were made by smart people, all the way down
  - abstraction is for those who fear understanding the problem
  - most hard problems are solved, complexity is artificial
- [ ] simulation games are not realistic
  - racing games use raycast physics
  - every game allows players to maneuver in air
  - many games tweak physics for gameplay purposes making it unrealistic
    - GTA V bike gliding
    - Trials Rising fender grab and vertical climbing
- [ ] the history of simple software
    - clash with VC strategy
- [ ] another git trick you will use `git update-index --assume-unchanged`
- [ ] seamless Tailscale and LAN DNS names: simplest approach
- [ ] phones are too big for PC users
- [ ] your website does not need a search bar
    - put whole content on the screen so users can <c-f>
- [ ] the internet? it's just 4 websites
    - hostile place for tech-savvy and privacy-aware users
- [ ] github code search is really powerful
- [ ] "screenshot" programs
    - every text editor is a `cat`
    - interactivite programs inherently require functionality useful without interactivity
- [ ] behavior and data are not the same
    - why Zig has no first class functions/closures
- [ ] programming language from first principles
    - what is inconvenient about writing raw machine code?
        * platform specific
        * no type system
        * manual register selection
        * error-prone control flow
    - where is the boundary between language features and libraries?
        * userland mechanisms to extend the language? macros, comptime
    - where is the boundary between comptime and runtime?
    - what features C lacks and what feels dated?
    - C ABI compartibility is everything
- [ ] how programming for fun is different
    - world of hobby programming
    - "get shit done" mentality
- [ ] programmer assumptions
    - what makes programs incorrect so much that rewrite is needed
    - billion dollar mistakes stories were caused by it
    - how to assert assumptions are correct
    - "premature optimization is evil" - weak and strong assumpitons
